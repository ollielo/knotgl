// Generated by CoffeeScript 1.3.1
(function() {
  var EPSILON, InitBuffers, MobiusTube, Render, Slices, TWOPI, abs, cos, modelview, normalMatrix, pow, projection, root, sgn, sin, theta, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  root.POSITION = 0;

  root.NORMAL = 1;

  Slices = 128;

  root.Stacks = 128;

  TWOPI = 2 * Math.PI;

  EPSILON = 0.0001;

  theta = 0;

  projection = mat4.create();

  modelview = mat4.create();

  normalMatrix = mat3.create();

  _ref = [Math.sin, Math.cos, Math.pow, Math.abs], sin = _ref[0], cos = _ref[1], pow = _ref[2], abs = _ref[3];

  Render = function() {
    var gl, stride, vbo, _ref1;
    _ref1 = [root.gl, root.vbo], gl = _ref1[0], vbo = _ref1[1];
    gl.clearColor(0.5, 0.5, 0.5, 1);
    gl.clear(gl.COLOR_BUFFER_BIT);
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    gl.enableVertexAttribArray(root.POSITION);
    gl.vertexAttribPointer(root.POSITION, 3, gl.FLOAT, false, stride = 12, 0);
    gl.drawArrays(gl.TRIANGLES, 0, vbo.vertCount);
    if (gl.getError() !== gl.NO_ERROR) {
      return glerr("OpenGL error");
    }
  };

  InitBuffers = function() {
    var A, B, BmA, C, CmA, gl, i, n, p, rawBuffer, slice, stack, u, v, vbo, vertex, vertices, _ref1, _ref2, _ref3;
    gl = root.gl;
    vbo = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
    vertices = [0.0, 1.0, 0.0, -0.2, -1.0, 0.0, 1.0, -1.0, 0.0];
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
    vbo.vertCount = 3;
    rawBuffer = new Float32Array(Slices * root.Stacks * 8);
    _ref1 = [-1, 0], slice = _ref1[0], i = _ref1[1];
    BmA = CmA = n = vec3.create();
    while (++slice < Slices) {
      _ref2 = [slice * TWOPI / Slices, -1], v = _ref2[0], stack = _ref2[1];
      while (++stack < root.Stacks) {
        u = stack * TWOPI / root.Stacks;
        A = p = MobiusTube(u, v);
        B = MobiusTube(u + EPSILON, v);
        C = MobiusTube(u, v + EPSILON);
        vec3.subtract(B, A, BmA);
        vec3.subtract(C, A, CmA);
        vec3.cross(BmA, CmA, n);
        vec3.normalize(n, n);
        _ref3 = [rawBuffer.subarray(i, i + 8), i + 8], vertex = _ref3[0], i = _ref3[1];
        vertex[0] = p.x;
        vertex[1] = p.y;
        vertex[2] = p.z;
        vertex[3] = n.x;
        vertex[4] = n.y;
        vertex[5] = n.z;
        vertex[6] = u;
        vertex[7] = v;
      }
    }
    glinfo("" + i + " floats from " + Slices + " slices and " + Stacks + " stacks.");
    /*
        for (int slice = 0; slice < Slices; slice++) {
            float v = slice * TwoPi / slices;
            for (int stack = 0; stack < root.Stacks; stack++) {
                float u = stack * TwoPi / stacks;
    
                float alpha = 0.8;   // 0.15 for horn, 1.0 for snail
                float beta = 1;
                float gamma = 0.1; // tightness
                float n = 2;       // twists
    
                Point3 p = ParametricHorn(u, v, alpha, beta, gamma, n);
                *position++ = p.x;
                *position++ = p.y;
                *position++ = p.z;
            }
        }
    */

    return root.vbo = vbo;
  };

  sgn = function(x) {
    if (x > 0) {
      return +1;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    }
  };

  MobiusTube = function(u, v) {
    var R, n, x, y, z, _ref1;
    _ref1 = [1.5, 3], R = _ref1[0], n = _ref1[1];
    x = (1.0 * R + 0.125 * sin(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v)) + 0.5 * cos(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v))) * cos(u);
    y = (1.0 * R + 0.125 * sin(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v)) + 0.5 * cos(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v))) * sin(u);
    z = -0.5 * sin(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v)) + 0.125 * cos(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v));
    return vec3.create([x, y, z]);
  };

  root.AppInit = function() {
    var canvas, depthProgram, fragmentShader, gl, h, vertexShader, w;
    canvas = $("canvas");
    w = parseInt(canvas.css('width'));
    h = parseInt(canvas.css('height'));
    canvas.css('margin-left', -w / 2);
    canvas.css('margin-top', -h / 2);
    root.gl = gl = canvas.get(0).getContext("experimental-webgl", {
      antialias: true
    });
    if (!gl.getExtension("OES_texture_float")) {
      glerr("Your browser does not support floating-point textures.");
    }
    InitBuffers();
    vertexShader = getShader(gl, "VS-Scene");
    fragmentShader = getShader(gl, "FS-Depth");
    depthProgram = gl.createProgram();
    gl.attachShader(depthProgram, vertexShader);
    gl.attachShader(depthProgram, fragmentShader);
    gl.bindAttribLocation(depthProgram, root.POSITION, "Position");
    gl.bindAttribLocation(depthProgram, root.NORMAL, "Normal");
    gl.linkProgram(depthProgram);
    if (!gl.getProgramParameter(depthProgram, gl.LINK_STATUS)) {
      glerr('Could not link shaders');
    }
    gl.useProgram(depthProgram);
    depthProgram.projectionUniform = gl.getUniformLocation(depthProgram, "Projection");
    depthProgram.modelviewUniform = gl.getUniformLocation(depthProgram, "Modelview");
    depthProgram.normalMatrixUniform = gl.getUniformLocation(depthProgram, "NormalMatrix");
    gl.disable(gl.CULL_FACE);
    gl.disable(gl.DEPTH_TEST);
    canvas.width = canvas.clientWidth;
    canvas.height = canvas.clientHeight;
    root.gl = gl;
    return setInterval(Render, 15);
  };

}).call(this);
