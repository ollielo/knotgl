// Generated by CoffeeScript 1.3.1
(function() {
  var Renderer, Style, TWOPI, aabb, abs, cos, dot, f, pow, root, sgn, sin, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Renderer = (function() {

    Renderer.name = 'Renderer';

    function Renderer(gl, width, height) {
      this.gl = gl;
      this.width = width;
      this.height = height;
      this.radiansPerSecond = 0.0003;
      this.transitionMilliseconds = 750;
      this.spinning = true;
      this.style = Style.SILHOUETTE;
      this.sketchy = true;
      this.theta = 0;
      this.vbos = {};
      this.programs = {};
      this.selectedColumn = 0;
      this.hotMouse = false;
      this.tubeGen = new root.TubeGenerator;
      this.tubeGen.polygonSides = 10;
      this.tubeGen.bézierSlices = 3;
      this.tubeGen.tangentSmoothness = 3;
      this.compileShaders();
      this.gl.disable(this.gl.CULL_FACE);
      if (this.gl.getError() !== this.gl.NO_ERROR) {
        glerr("OpenGL error during init");
      }
      this.downloadSpines();
    }

    Renderer.prototype.onDownloadComplete = function(data) {
      var Colors, TableRow, id, knot, link, range, ranges, rawVerts, x, _i, _j, _len, _len1, _ref;
      rawVerts = data['centerlines'];
      this.spines = new Float32Array(rawVerts);
      this.vbos.spines = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.spines);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, this.spines, this.gl.STATIC_DRAW);
      if (this.gl.getError() !== this.gl.NO_ERROR) {
        glerr("Error when trying to create spine VBO");
      }
      toast("downloaded " + (this.spines.length / 3) + " verts of spine data");
      Colors = [[1, 1, 1, 0.75], [0.25, 0.5, 1, 0.75], [1, 0.5, 0.25, 0.75]];
      TableRow = "7.2.3 7.2.4 7.2.5 7.2.6 7.2.7 7.2.8 8.2.1 8.2.2 8.2.3";
      this.links = [];
      _ref = TableRow.split(' ');
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        link = [];
        ranges = ((function() {
          var _j, _len1, _ref1, _results;
          _ref1 = root.links;
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            x = _ref1[_j];
            if (x[0] === id) {
              _results.push(x.slice(1));
            }
          }
          return _results;
        })())[0];
        for (_j = 0, _len1 = ranges.length; _j < _len1; _j++) {
          range = ranges[_j];
          knot = {};
          knot.range = range;
          knot.vbos = this.tessKnot(range);
          knot.color = Colors[ranges.indexOf(range)];
          link.push(knot);
        }
        link.iconified = 1;
        link.id = id;
        this.links.push(link);
      }
      this.links[this.selectedColumn].iconified = 0;
      root.UpdateLabels();
      return this.render();
    };

    Renderer.prototype.getCurrentLinkInfo = function() {
      var L, X;
      X = this.links[this.selectedColumn].id.split('.');
      L = {
        crossings: X[0],
        numComponents: X[1],
        index: X[2]
      };
      if (L.numComponents === 1) {
        L.numComponents = "";
      }
      return L;
    };

    Renderer.prototype.moveSelection = function(increment) {
      var currentSelection, nextSelection;
      currentSelection = this.selectedColumn;
      nextSelection = currentSelection + increment;
      if (nextSelection >= this.links.length || nextSelection < 0) {
        return;
      }
      if (nextSelection === currentSelection) {
        return;
      }
      return this.changeSelection(nextSelection);
    };

    Renderer.prototype.changeSelection = function(nextSelection) {
      var currentSelection, iconified;
      currentSelection = this.selectedColumn;
      this.selectedColumn = nextSelection;
      root.AnimateNumerals();
      iconified = this.links[currentSelection].iconified;
      if (iconified === 0) {
        root.outgoing = new TWEEN.Tween(this.links[currentSelection]).to({
          iconified: 1
        }, 0.5 * this.transitionMilliseconds).easing(TWEEN.Easing.Quartic.Out);
        root.incoming = new TWEEN.Tween(this.links[nextSelection]).to({
          iconified: 0
        }, this.transitionMilliseconds).easing(TWEEN.Easing.Bounce.Out);
        root.incoming.start();
        root.outgoing.start();
        return;
      }
      this.links[currentSelection].iconified = 1;
      this.links[nextSelection].iconified = iconified;
      return root.incoming.replace(this.links[nextSelection]);
    };

    Renderer.prototype.downloadSpines = function() {
      var worker;
      worker = new Worker('js/downloader.js');
      worker.renderer = this;
      worker.onmessage = function(response) {
        return this.renderer.onDownloadComplete(response.data);
      };
      return worker.postMessage(document.URL + 'data/centerlines.bin');
    };

    Renderer.prototype.compileShaders = function() {
      var fs, metadata, name, vs, _ref, _ref1, _results;
      _ref = root.shaders;
      _results = [];
      for (name in _ref) {
        metadata = _ref[name];
        if (name === "source") {
          continue;
        }
        _ref1 = metadata.keys, vs = _ref1[0], fs = _ref1[1];
        _results.push(this.programs[name] = this.compileProgram(vs, fs, metadata.attribs, metadata.uniforms));
      }
      return _results;
    };

    Renderer.prototype.render = function() {
      var aspect, currentTime, cursor, elapsed, eye, far, fov, knot, link, model, near, pass, r, target, up, view, _i, _j, _k, _l, _len, _len1, _len2, _len3, _m, _ref, _ref1;
      r = function() {
        return root.renderer.render();
      };
      window.requestAnimationFrame(r, $("canvas").get(0));
      TWEEN.update();
      if (root.UpdateLabels != null) {
        root.UpdateLabels();
      }
      cursor = this.hotMouse || window.mouse.hot ? 'pointer' : '';
      $('#rightpage').css({
        'cursor': cursor
      });
      $('#leftpage').css({
        'cursor': cursor
      });
      currentTime = new Date().getTime();
      if (this.previousTime != null) {
        elapsed = currentTime - this.previousTime;
        if (this.spinning) {
          this.theta += this.radiansPerSecond * elapsed;
        }
      }
      this.previousTime = currentTime;
      this.projection = mat4.perspective(fov = 45, aspect = this.width / this.height, near = 5, far = 90);
      view = mat4.lookAt(eye = [0, -5, 5], target = [0, 0, 0], up = [0, 1, 0]);
      model = mat4.create();
      this.modelview = mat4.create();
      mat4.identity(model);
      mat4.rotateX(model, 3.14 / 4);
      mat4.rotateY(model, this.theta);
      mat4.multiply(view, model, this.modelview);
      this.normalMatrix = mat4.toMat3(this.modelview);
      this.updateViewports();
      _ref = this.links;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        for (_j = 0, _len1 = link.length; _j < _len1; _j++) {
          knot = link[_j];
          this.renderIconKnot(knot, link);
        }
      }
      for (pass = _k = 0; _k <= 1; pass = ++_k) {
        _ref1 = this.links;
        for (_l = 0, _len2 = _ref1.length; _l < _len2; _l++) {
          link = _ref1[_l];
          for (_m = 0, _len3 = link.length; _m < _len3; _m++) {
            knot = link[_m];
            this.renderBigKnot(knot, link, pass);
          }
        }
      }
      if (this.gl.getError() !== this.gl.NO_ERROR) {
        return glerr("Render");
      }
    };

    Renderer.prototype.updateViewports = function() {
      var bigBox, d, distance, h, iconBox, link, maxExpansion, mouse, radius, tileHeight, tileWidth, w, x, y, _i, _len, _ref, _results;
      w = tileWidth = this.width / this.links.length;
      h = tileHeight = tileWidth * this.height / this.width;
      y = this.height - tileHeight / 2;
      x = tileWidth / 2;
      bigBox = new aabb(0, 0, this.width, this.height);
      mouse = vec2.create([root.mouse.position.x, this.height - root.mouse.position.y]);
      this.hotMouse = false;
      _ref = this.links;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        iconBox = aabb.createFromCenter([x, y], [w, h]);
        distance = vec2.dist([x, y], mouse);
        radius = h / 2;
        if (distance < radius && link.iconified === 1) {
          d = 1 - distance / radius;
          maxExpansion = radius / 3;
          iconBox.inflate(d * d * maxExpansion);
          this.hotMouse = true;
        }
        link.iconBox = iconBox;
        link.centralBox = aabb.lerp(bigBox, iconBox, link.iconified);
        _results.push(x = x + w);
      }
      return _results;
    };

    Renderer.prototype.click = function() {
      var link, mouse, _i, _len, _ref, _results;
      if (!(this.links != null) || this.links.length === 0) {
        return;
      }
      mouse = vec2.create([root.mouse.position.x, this.height - root.mouse.position.y]);
      _ref = this.links;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        link = _ref[_i];
        if (link.iconBox.contains(mouse[0], mouse[1]) && link.iconified === 1) {
          _results.push(this.changeSelection(this.links.indexOf(link)));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Renderer.prototype.setColor = function(loc, c, α) {
      return this.gl.uniform4f(loc, c[0], c[1], c[2], α);
    };

    Renderer.prototype.setViewport = function(box, projectionUniform) {
      var clippedBox, cropMatrix, entireViewport, proj;
      box = box.translated(window.pan.x, 0);
      entireViewport = new aabb(0, 0, this.width, this.height);
      clippedBox = aabb.intersect(box, entireViewport);
      if (clippedBox.degenerate()) {
        this.gl.viewport(0, 0, 1, 1);
        return;
      }
      cropMatrix = aabb.cropMatrix(clippedBox, box);
      proj = mat4.create(this.projection);
      mat4.multiply(proj, cropMatrix);
      this.gl.uniformMatrix4fv(projectionUniform, false, proj);
      return clippedBox.viewport(this.gl);
    };

    Renderer.prototype.renderIconKnot = function(knot, link) {
      var alpha, program, startVertex, stride, vertexCount, x, y, _i, _j, _ref;
      program = this.programs.wireframe;
      this.gl.useProgram(program);
      this.setViewport(link.iconBox, program.projection);
      this.gl.enable(this.gl.BLEND);
      this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.spines);
      this.gl.enableVertexAttribArray(POSITION);
      this.gl.vertexAttribPointer(POSITION, 3, this.gl.FLOAT, false, stride = 12, 0);
      this.gl.uniformMatrix4fv(program.modelview, false, this.modelview);
      this.gl.uniform1f(program.scale, this.tubeGen.scale);
      alpha = 0.25 + 0.75 * link.iconified;
      this.setColor(program.color, COLORS.black, alpha);
      _ref = knot.range, startVertex = _ref[0], vertexCount = _ref[1];
      this.gl.enable(this.gl.DEPTH_TEST);
      this.gl.lineWidth(2);
      for (x = _i = -1; _i <= 1; x = _i += 2) {
        for (y = _j = -1; _j <= 1; y = _j += 2) {
          this.gl.uniform2f(program.offset, x, y);
          this.gl.uniform1f(program.depthOffset, 0);
          this.gl.drawArrays(this.gl.LINE_LOOP, startVertex, vertexCount);
        }
      }
      this.setColor(program.color, knot.color, alpha);
      this.gl.uniform2f(program.offset, 0, 0);
      this.gl.uniform1f(program.depthOffset, -0.5);
      this.gl.drawArrays(this.gl.LINE_LOOP, startVertex, vertexCount);
      return this.gl.disableVertexAttribArray(POSITION);
    };

    Renderer.prototype.renderBigKnot = function(knot, link, pass) {
      var offset, program, stride, vbos;
      if (link.iconified === 1) {
        return;
      }
      if (!(knot.vbos != null)) {
        return;
      }
      vbos = knot.vbos;
      if (pass === 0) {
        program = this.programs.solidmesh;
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.useProgram(program);
        this.setViewport(link.centralBox, program.projection);
        this.setColor(program.color, knot.color, 1);
        this.gl.uniformMatrix4fv(program.modelview, false, this.modelview);
        this.gl.uniformMatrix3fv(program.normalmatrix, false, this.normalMatrix);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbos.tube);
        this.gl.enableVertexAttribArray(POSITION);
        this.gl.enableVertexAttribArray(NORMAL);
        this.gl.vertexAttribPointer(POSITION, 3, this.gl.FLOAT, false, stride = 24, 0);
        this.gl.vertexAttribPointer(NORMAL, 3, this.gl.FLOAT, false, stride = 24, offset = 12);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbos.triangles);
        if (this.style === Style.SILHOUETTE) {
          this.gl.enable(this.gl.POLYGON_OFFSET_FILL);
          this.gl.polygonOffset(-1, 12);
        }
        this.gl.drawElements(this.gl.TRIANGLES, vbos.triangles.count, this.gl.UNSIGNED_SHORT, 0);
        this.gl.disableVertexAttribArray(POSITION);
        this.gl.disableVertexAttribArray(NORMAL);
        this.gl.disable(this.gl.POLYGON_OFFSET_FILL);
      }
      if (pass === 1) {
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        program = this.programs.wireframe;
        this.gl.useProgram(program);
        this.setViewport(link.centralBox, program.projection);
        this.gl.uniformMatrix4fv(program.modelview, false, this.modelview);
        this.gl.uniform1f(program.scale, 1);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbos.tube);
        this.gl.enableVertexAttribArray(POSITION);
        this.gl.vertexAttribPointer(POSITION, 3, this.gl.FLOAT, false, stride = 24, 0);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbos.wireframe);
        if (this.style === Style.WIREFRAME) {
          this.gl.lineWidth(1);
          this.gl.uniform1f(program.depthOffset, -0.01);
          this.setColor(program.color, COLORS.black, 0.75);
          this.gl.drawElements(this.gl.LINES, vbos.wireframe.count, this.gl.UNSIGNED_SHORT, 0);
        } else if (this.style === Style.RINGS) {
          this.gl.lineWidth(1);
          this.gl.uniform1f(program.depthOffset, -0.01);
          this.setColor(program.color, COLORS.black, 0.75);
          this.gl.drawElements(this.gl.LINES, vbos.wireframe.count / 2, this.gl.UNSIGNED_SHORT, vbos.wireframe.count);
        } else {
          this.gl.lineWidth(2);
          this.gl.uniform1f(program.depthOffset, 0.01);
          this.setColor(program.color, COLORS.black, 1);
          this.gl.drawElements(this.gl.LINES, vbos.wireframe.count, this.gl.UNSIGNED_SHORT, 0);
          if (this.sketchy) {
            this.gl.lineWidth(1);
            this.setColor(program.color, COLORS.darkgray, 1);
            this.gl.uniform1f(program.depthOffset, -0.01);
            this.gl.drawElements(this.gl.LINES, vbos.wireframe.count / 2, this.gl.UNSIGNED_SHORT, vbos.wireframe.count);
          }
        }
        return this.gl.disableVertexAttribArray(POSITION);
      }
    };

    Renderer.prototype.tessKnot = function(component) {
      var byteOffset, centerline, faceCount, i, j, lineCount, next, numFloats, polygonCount, polygonEdge, ptr, rawBuffer, segmentData, sides, sweepEdge, tri, triangles, tube, v, vbo, vbos, wireframe, _ref, _ref1, _ref2, _ref3;
      byteOffset = component[0] * 3 * 4;
      numFloats = component[1] * 3;
      segmentData = this.spines.subarray(component[0] * 3, component[0] * 3 + component[1] * 3);
      centerline = this.tubeGen.getKnotPath(segmentData);
      rawBuffer = this.tubeGen.generateTube(centerline);
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      console.log("Tube positions has " + (rawBuffer.length / 3) + " verts.");
      tube = vbo;
      polygonCount = centerline.length / 3 - 1;
      sides = this.tubeGen.polygonSides;
      lineCount = polygonCount * sides * 2;
      rawBuffer = new Uint16Array(lineCount * 2);
      _ref = [0, 0], i = _ref[0], ptr = _ref[1];
      while (i < polygonCount * (sides + 1)) {
        j = 0;
        while (j < sides) {
          sweepEdge = rawBuffer.subarray(ptr + 2, ptr + 4);
          sweepEdge[0] = i + j;
          sweepEdge[1] = i + j + sides + 1;
          _ref1 = [ptr + 2, j + 1], ptr = _ref1[0], j = _ref1[1];
        }
        i += sides + 1;
      }
      i = 0;
      while (i < polygonCount * (sides + 1)) {
        j = 0;
        while (j < sides) {
          polygonEdge = rawBuffer.subarray(ptr + 0, ptr + 2);
          polygonEdge[0] = i + j;
          polygonEdge[1] = i + j + 1;
          _ref2 = [ptr + 2, j + 1], ptr = _ref2[0], j = _ref2[1];
        }
        i += sides + 1;
      }
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      wireframe = vbo;
      wireframe.count = rawBuffer.length;
      console.log("Tube wireframe has " + rawBuffer.length + " indices for " + sides + " sides and " + (centerline.length / 3 - 1) + " polygons.");
      faceCount = centerline.length / 3 * sides * 2;
      rawBuffer = new Uint16Array(faceCount * 3);
      _ref3 = [0, 0, 0], i = _ref3[0], ptr = _ref3[1], v = _ref3[2];
      while (++i < centerline.length / 3) {
        j = -1;
        while (++j < sides) {
          next = (j + 1) % sides;
          tri = rawBuffer.subarray(ptr + 0, ptr + 3);
          tri[0] = v + next + sides + 1;
          tri[1] = v + next;
          tri[2] = v + j;
          tri = rawBuffer.subarray(ptr + 3, ptr + 6);
          tri[0] = v + j;
          tri[1] = v + j + sides + 1;
          tri[2] = v + next + sides + 1;
          ptr += 6;
        }
        v += sides + 1;
      }
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      triangles = vbo;
      triangles.count = rawBuffer.length;
      return vbos = {
        tube: tube,
        wireframe: wireframe,
        triangles: triangles
      };
    };

    Renderer.prototype.compileProgram = function(vName, fName, attribs, uniforms) {
      var compileShader, fShader, fSource, key, program, status, vShader, vSource, value;
      compileShader = function(gl, name, handle) {
        var status;
        gl.compileShader(handle);
        status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);
        if (!status) {
          return $.gritter.add({
            title: "GLSL Error: " + name,
            text: gl.getShaderInfoLog(handle)
          });
        }
      };
      vSource = root.shaders.source[vName];
      vShader = this.gl.createShader(this.gl.VERTEX_SHADER);
      this.gl.shaderSource(vShader, vSource);
      compileShader(this.gl, vName, vShader);
      fSource = root.shaders.source[fName];
      fShader = this.gl.createShader(this.gl.FRAGMENT_SHADER);
      this.gl.shaderSource(fShader, fSource);
      compileShader(this.gl, fName, fShader);
      program = this.gl.createProgram();
      this.gl.attachShader(program, vShader);
      this.gl.attachShader(program, fShader);
      for (key in attribs) {
        value = attribs[key];
        this.gl.bindAttribLocation(program, value, key);
      }
      this.gl.linkProgram(program);
      status = this.gl.getProgramParameter(program, this.gl.LINK_STATUS);
      if (!status) {
        glerr("Could not link " + vName + " with " + fName);
      }
      for (key in uniforms) {
        value = uniforms[key];
        program[value] = this.gl.getUniformLocation(program, key);
      }
      return program;
    };

    return Renderer;

  })();

  root.Renderer = Renderer;

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = "sin cos pow abs".split(' ');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      _results.push(Math[f]);
    }
    return _results;
  })(), sin = _ref[0], cos = _ref[1], pow = _ref[2], abs = _ref[3];

  dot = vec3.dot;

  sgn = function(x) {
    if (x > 0) {
      return +1;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    }
  };

  TWOPI = 2 * Math.PI;

  aabb = root.utility.aabb;

  Style = {
    WIREFRAME: 0,
    SILHOUETTE: 1,
    RINGS: 2
  };

}).call(this);
