// Generated by CoffeeScript 1.3.1
(function() {
  var Renderer, Style, TWOPI, aabb, abs, clone, cos, dot, f, gl, pow, root, sgn, sin, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  gl = null;

  Renderer = (function() {

    Renderer.name = 'Renderer';

    Renderer.prototype.renderIconLink = function(link, viewbox, alpha) {
      var knot, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = link.length; _i < _len; _i++) {
        knot = link[_i];
        _results.push(this.renderIconKnot(knot, link, viewbox, alpha));
      }
      return _results;
    };

    Renderer.prototype.renderBigLink = function(link, pass) {
      var knot, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = link.length; _i < _len; _i++) {
        knot = link[_i];
        _results.push(this.renderBigKnot(knot, link, pass));
      }
      return _results;
    };

    function Renderer(context, width, height) {
      var msg,
        _this = this;
      this.width = width;
      this.height = height;
      gl = context;
      this.ready = false;
      this.radiansPerSecond = 0.0003;
      this.transitionMilliseconds = 750;
      this.style = Style.SILHOUETTE;
      this.sketchy = true;
      this.programs = {};
      this.selectedColumn = 0;
      this.selectedRow = 9;
      this.hotMouse = false;
      this.initializeGL();
      this.parseMetadata();
      this.worker = new Worker('js/worker.js');
      this.worker.onmessage = function(response) {
        return _this.onWorkerMessage(response.data);
      };
      msg = {
        command: 'download-spines',
        url: document.URL + 'data/centerlines.bin'
      };
      this.worker.postMessage(msg);
    }

    Renderer.prototype.render = function() {
      var aspect, currentTime, dt, elapsed, eye, far, fov, getAlpha, link, model, near, pass, row, rowIndex, spinningRow, target, up, view, _i, _j, _k, _l, _len, _len1, _len2, _len3, _len4, _m, _n, _ref, _ref1;
      currentTime = new Date().getTime();
      if (this.previousTime != null) {
        elapsed = currentTime - this.previousTime;
        dt = this.radiansPerSecond * elapsed;
        if (root.pageIndex === 0) {
          dt = dt * 32;
        }
        spinningRow = this.highlightRow != null ? this.links[this.highlightRow] : null;
        _ref = this.links;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          row = _ref[_i];
          if (row === spinningRow || Math.abs(row.theta % TWOPI) > dt) {
            row.theta += dt;
          } else {
            row.theta = 0;
          }
        }
      }
      this.previousTime = currentTime;
      this.projection = mat4.perspective(fov = 45, aspect = this.width / this.height, near = 5, far = 90);
      view = mat4.lookAt(eye = [0, -5, 5], target = [0, 0, 0], up = [0, 1, 0]);
      this.updateViewports();
      getAlpha = function(link) {
        return 0.25 + 0.75 * link.iconified;
      };
      _ref1 = this.links;
      for (rowIndex = _j = 0, _len1 = _ref1.length; _j < _len1; rowIndex = ++_j) {
        row = _ref1[rowIndex];
        model = mat4.create();
        this.modelview = mat4.create();
        mat4.identity(model);
        mat4.rotateX(model, 3.14 / 4);
        mat4.rotateY(model, row.theta);
        mat4.multiply(view, model, this.modelview);
        this.normalMatrix = mat4.toMat3(this.modelview);
        for (_k = 0, _len2 = row.length; _k < _len2; _k++) {
          link = row[_k];
          if (!(link.hidden != null)) {
            this.renderIconLink(link, link.tableBox, 1);
          }
        }
        if (rowIndex === this.selectedRow) {
          for (_l = 0, _len3 = row.length; _l < _len3; _l++) {
            link = row[_l];
            if (link.ready) {
              this.renderIconLink(link, link.iconBox, getAlpha(link));
            }
          }
          for (pass = _m = 0; _m <= 1; pass = ++_m) {
            for (_n = 0, _len4 = row.length; _n < _len4; _n++) {
              link = row[_n];
              this.renderBigLink(link, pass);
            }
          }
        }
      }
      if (gl.getError() !== gl.NO_ERROR) {
        return glerr("Render");
      }
    };

    Renderer.prototype.initializeGL = function() {
      this.compileShaders();
      gl.enable(gl.CULL_FACE);
      if (gl.getError() !== gl.NO_ERROR) {
        return glerr("OpenGL error during init");
      }
    };

    Renderer.prototype.parseMetadata = function() {
      var c, col, id, knot, link, range, ranges, row, trivialKnot, trivialLink, x, _i, _j, _k, _len, _len1, _ref;
      this.links = [];
      for (row = _i = 0; _i < 12; row = ++_i) {
        this.links[row] = [];
        this.links[row].theta = 0;
        this.links[row].loaded = false;
        this.links[row].loading = false;
        if (!metadata.Gallery[row]) {
          continue;
        }
        _ref = metadata.Gallery[row].split(' ');
        for (col = _j = 0, _len = _ref.length; _j < _len; col = ++_j) {
          id = _ref[col];
          link = [];
          ranges = ((function() {
            var _k, _len1, _ref1, _results;
            _ref1 = metadata.Links;
            _results = [];
            for (_k = 0, _len1 = _ref1.length; _k < _len1; _k++) {
              x = _ref1[_k];
              if (x[0] === id) {
                _results.push(x.slice(1));
              }
            }
            return _results;
          })())[0];
          for (c = _k = 0, _len1 = ranges.length; _k < _len1; c = ++_k) {
            range = ranges[c];
            knot = {};
            knot.range = range;
            knot.offset = vec3.create([0, 0, 0]);
            knot.color = metadata.KnotColors[c];
            link.push(knot);
          }
          link.iconified = 1;
          link.ready = false;
          link.id = [id, row, col];
          this.links[row].push(link);
        }
      }
      trivialKnot = this.links[8][1][0];
      trivialLink = this.links[0][0];
      trivialLink.push(clone(trivialKnot));
      trivialLink[0].offset = vec3.create([0.5, -0.25, 0]);
      trivialLink.hidden = true;
      trivialLink = this.links[8][0];
      trivialLink.push(clone(trivialKnot));
      trivialLink.push(clone(trivialKnot));
      trivialLink[0].offset = vec3.create([0, 0, 0]);
      trivialLink[1].color = metadata.KnotColors[1];
      trivialLink[1].offset = vec3.create([0.5, 0, 0]);
      trivialLink = this.links[10][8];
      trivialLink.push(clone(trivialKnot));
      trivialLink.push(clone(trivialKnot));
      trivialLink.push(clone(trivialKnot));
      trivialLink[0].offset = vec3.create([0, 0, 0]);
      trivialLink[1].color = metadata.KnotColors[1];
      trivialLink[1].offset = vec3.create([0.5, 0, 0]);
      trivialLink[2].color = metadata.KnotColors[2];
      trivialLink[2].offset = vec3.create([1.0, 0, 0]);
      return this.links[this.selectedRow][this.selectedColumn].iconified = 0;
    };

    Renderer.prototype.onWorkerMessage = function(msg) {
      var col, i, id, link, mesh, row, v, _i, _len, _ref, _ref1;
      switch (msg.command) {
        case 'debug-message':
          return toast(msg.text);
        case 'spine-data':
          this.spines = this.createVbo(gl.ARRAY_BUFFER, msg.data);
          this.spines.scale = msg.scale;
          this.tessRow(this.links[this.selectedRow]);
          return this.ready = true;
        case 'mesh-link':
          _ref = msg.id, id = _ref[0], row = _ref[1], col = _ref[2];
          link = this.links[row][col];
          _ref1 = msg.meshes;
          for (i = _i = 0, _len = _ref1.length; _i < _len; i = ++_i) {
            mesh = _ref1[i];
            v = link[i].vbos = {};
            v.tube = this.createVbo(gl.ARRAY_BUFFER, mesh.tube);
            v.wireframe = this.createVbo(gl.ELEMENT_ARRAY_BUFFER, mesh.wireframe);
            v.triangles = this.createVbo(gl.ELEMENT_ARRAY_BUFFER, mesh.triangles);
          }
          row = this.links[row];
          if (++row.loadCount === row.length) {
            row.loaded = true;
            row.loading = false;
          }
          return link.ready = true;
      }
    };

    Renderer.prototype.createVbo = function(target, data) {
      var vbo;
      vbo = gl.createBuffer();
      gl.bindBuffer(target, vbo);
      gl.bufferData(target, data, gl.STATIC_DRAW);
      vbo.count = data.length;
      return vbo;
    };

    Renderer.prototype.tessRow = function(row) {
      var knot, link, msg, _i, _len, _results;
      if (row.loaded || row.loading) {
        return;
      }
      row.loading = true;
      row.loadCount = 0;
      _results = [];
      for (_i = 0, _len = row.length; _i < _len; _i++) {
        link = row[_i];
        msg = {
          command: 'tessellate-link',
          id: link.id,
          link: (function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (_j = 0, _len1 = link.length; _j < _len1; _j++) {
              knot = link[_j];
              _results1.push(knot.range);
            }
            return _results1;
          })()
        };
        _results.push(this.worker.postMessage(msg));
      }
      return _results;
    };

    Renderer.prototype.getCurrentLinkInfo = function() {
      var X;
      X = this.links[this.selectedRow][this.selectedColumn].id[0].split('.');
      if (X.length === 2) {
        return {
          crossings: X[0],
          numComponents: "",
          index: X[1]
        };
      }
      return {
        crossings: X[0],
        numComponents: X[1],
        index: X[2]
      };
    };

    Renderer.prototype.moveSelection = function(dx, dy) {
      var nextX, nextY;
      nextX = this.selectedColumn + dx;
      nextY = this.selectedRow + dy;
      if (nextY >= this.links.length || nextY < 0) {
        return;
      }
      if (nextX >= this.links[nextY].length || nextX < 0) {
        return;
      }
      return this.changeSelection(nextX, nextY);
    };

    Renderer.prototype.changeSelection = function(nextX, nextY) {
      var changingRow, duration, iconified, link, previousColumn, row, _i, _len, _ref;
      previousColumn = this.selectedColumn;
      changingRow = false;
      if (nextY !== this.selectedRow) {
        _ref = this.links[nextY];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          link = _ref[_i];
          link.iconified = 1;
        }
        if (!this.links[nextY][nextX].ready) {
          nextX = 0;
        }
        this.links[nextY][nextX].iconified = 0;
        this.highlightRow = nextY;
        changingRow = true;
      }
      this.selectedColumn = nextX;
      this.selectedRow = nextY;
      this.tessRow(this.links[this.selectedRow]);
      root.AnimateNumerals();
      row = this.links[this.selectedRow];
      if (changingRow) {
        return;
      }
      iconified = row[previousColumn].iconified;
      if (iconified === 0) {
        duration = this.transitionMilliseconds;
        this.incoming = new TWEEN.Tween(row[this.selectedColumn]).to({
          iconified: 0
        }, duration).easing(TWEEN.Easing.Bounce.Out).start();
        duration = 0.5 * this.transitionMilliseconds;
        this.outgoing = new TWEEN.Tween(row[previousColumn]).to({
          iconified: 1
        }, duration).easing(TWEEN.Easing.Quartic.Out).start();
        return;
      }
      row[previousColumn].iconified = 1;
      row[this.selectedColumn].iconified = iconified;
      if (this.incoming != null) {
        return this.incoming.replace(row[this.selectedColumn]);
      }
    };

    Renderer.prototype.updateViewports = function() {
      var bigBox, d, distance, h, iconBox, link, maxExpansion, mouse, radius, row, rowIndex, tileHeight, tileWidth, w, x, y, _i, _j, _len, _ref, _results;
      bigBox = new aabb(0, 0, this.width, this.height);
      mouse = vec2.create([root.mouse.position.x, this.height - root.mouse.position.y]);
      this.hotMouse = false;
      _results = [];
      for (rowIndex = _i = 0, _ref = this.links.length; 0 <= _ref ? _i < _ref : _i > _ref; rowIndex = 0 <= _ref ? ++_i : --_i) {
        row = this.links[rowIndex];
        h = tileHeight = this.height / this.links.length;
        w = tileHeight * this.width / this.height;
        tileWidth = this.width / (row.length + 0.5);
        x = -this.width + tileWidth / 2;
        y = this.height - tileHeight / 2 - tileHeight * rowIndex;
        for (_j = 0, _len = row.length; _j < _len; _j++) {
          link = row[_j];
          link.tableBox = aabb.createFromCenter([x, y], [w, h]);
          link.tableBox.inflate(w / 5, h / 5);
          x = x + tileWidth;
        }
        if (rowIndex !== this.selectedRow) {
          continue;
        }
        w = tileWidth = this.width / row.length;
        h = tileHeight = tileWidth * this.height / this.width;
        x = tileWidth / 2;
        y = this.height - tileHeight / 2;
        _results.push((function() {
          var _k, _len1, _results1;
          _results1 = [];
          for (_k = 0, _len1 = row.length; _k < _len1; _k++) {
            link = row[_k];
            iconBox = aabb.createFromCenter([x, y], [w, h]);
            distance = vec2.dist([x, y], mouse);
            radius = h / 2;
            if (distance < radius && link.iconified === 1) {
              d = 1 - distance / radius;
              maxExpansion = radius / 3;
              iconBox.inflate(d * d * maxExpansion);
              this.hotMouse = true;
            }
            link.iconBox = iconBox;
            link.centralBox = aabb.lerp(bigBox, iconBox, link.iconified);
            _results1.push(x = x + w);
          }
          return _results1;
        }).call(this));
      }
      return _results;
    };

    Renderer.prototype.click = function() {
      var link, mouse, row, _i, _len, _results;
      if (root.pageIndex === 0 && !(root.swipeTween != null)) {
        if (!(this.highlightRow != null)) {
          return;
        }
        this.changeSelection(this.selectedColumn, this.highlightRow);
        root.SwipePane();
        return;
      }
      if (!(this.links != null)) {
        return;
      }
      row = this.links[this.selectedRow];
      mouse = vec2.create([root.mouse.position.x, this.height - root.mouse.position.y]);
      _results = [];
      for (_i = 0, _len = row.length; _i < _len; _i++) {
        link = row[_i];
        if (!link || !link.iconBox) {
          continue;
        }
        if (link.iconBox.contains(mouse[0], mouse[1]) && link.iconified === 1) {
          _results.push(this.changeSelection(row.indexOf(link), this.selectedRow));
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    Renderer.prototype.setColor = function(loc, c, α) {
      return gl.uniform4f(loc, c[0], c[1], c[2], α);
    };

    Renderer.prototype.setViewport = function(box) {
      var clippedBox, cropMatrix, entireViewport, projection;
      box = box.translated(root.pan.x, 0);
      entireViewport = new aabb(0, 0, this.width, this.height);
      clippedBox = aabb.intersect(box, entireViewport);
      if (clippedBox.degenerate()) {
        return null;
      }
      cropMatrix = aabb.cropMatrix(clippedBox, box);
      projection = mat4.create(this.projection);
      mat4.multiply(projection, cropMatrix);
      clippedBox.viewport(gl);
      return projection;
    };

    Renderer.prototype.renderIconKnot = function(knot, link, viewbox, alpha) {
      var program, projection, startVertex, stride, vertexCount, x, y, _i, _j, _ref;
      projection = this.setViewport(viewbox);
      if (!projection) {
        return;
      }
      program = this.programs.wireframe;
      gl.useProgram(program);
      gl.uniform3f(program.worldOffset, knot.offset[0], knot.offset[1], knot.offset[2]);
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
      gl.bindBuffer(gl.ARRAY_BUFFER, this.spines);
      gl.enableVertexAttribArray(semantics.POSITION);
      gl.vertexAttribPointer(semantics.POSITION, 3, gl.FLOAT, false, stride = 12, 0);
      gl.uniformMatrix4fv(program.modelview, false, this.modelview);
      gl.uniformMatrix4fv(program.projection, false, projection);
      gl.uniform1f(program.scale, this.spines.scale);
      this.setColor(program.color, COLORS.black, alpha);
      _ref = knot.range, startVertex = _ref[0], vertexCount = _ref[1];
      gl.enable(gl.DEPTH_TEST);
      gl.lineWidth(2);
      for (x = _i = -1; _i <= 1; x = _i += 2) {
        for (y = _j = -1; _j <= 1; y = _j += 2) {
          gl.uniform2f(program.screenOffset, x, y);
          gl.uniform1f(program.depthOffset, 0);
          gl.drawArrays(gl.LINE_LOOP, startVertex, vertexCount);
        }
      }
      this.setColor(program.color, knot.color, alpha);
      gl.uniform2f(program.screenOffset, 0, 0);
      gl.uniform1f(program.depthOffset, -0.5);
      gl.drawArrays(gl.LINE_LOOP, startVertex, vertexCount);
      return gl.disableVertexAttribArray(semantics.POSITION);
    };

    Renderer.prototype.renderBigKnot = function(knot, link, pass) {
      var offset, program, projection, stride, vbos;
      if (link.iconified === 1) {
        return;
      }
      if (!(knot.vbos != null)) {
        return;
      }
      projection = this.setViewport(link.centralBox);
      if (!projection) {
        return;
      }
      vbos = knot.vbos;
      if (pass === 0) {
        program = this.programs.solidmesh;
        gl.enable(gl.DEPTH_TEST);
        gl.useProgram(program);
        this.setColor(program.color, knot.color, 1);
        gl.uniform3f(program.worldOffset, knot.offset[0], knot.offset[1], knot.offset[2]);
        gl.uniformMatrix4fv(program.modelview, false, this.modelview);
        gl.uniformMatrix3fv(program.normalmatrix, false, this.normalMatrix);
        gl.uniformMatrix4fv(program.projection, false, projection);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbos.tube);
        gl.enableVertexAttribArray(semantics.POSITION);
        gl.enableVertexAttribArray(semantics.NORMAL);
        gl.vertexAttribPointer(semantics.POSITION, 3, gl.FLOAT, false, stride = 24, 0);
        gl.vertexAttribPointer(semantics.NORMAL, 3, gl.FLOAT, false, stride = 24, offset = 12);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbos.triangles);
        if (this.style === Style.SILHOUETTE) {
          gl.enable(gl.POLYGON_OFFSET_FILL);
          gl.polygonOffset(-1, 12);
        }
        gl.drawElements(gl.TRIANGLES, vbos.triangles.count, gl.UNSIGNED_SHORT, 0);
        gl.disableVertexAttribArray(semantics.POSITION);
        gl.disableVertexAttribArray(semantics.NORMAL);
        gl.disable(gl.POLYGON_OFFSET_FILL);
      }
      if (pass === 1) {
        gl.enable(gl.BLEND);
        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
        program = this.programs.wireframe;
        gl.useProgram(program);
        gl.uniform3f(program.worldOffset, knot.offset[0], knot.offset[1], knot.offset[2]);
        gl.uniformMatrix4fv(program.modelview, false, this.modelview);
        gl.uniformMatrix4fv(program.projection, false, projection);
        gl.uniform1f(program.scale, 1);
        gl.bindBuffer(gl.ARRAY_BUFFER, vbos.tube);
        gl.enableVertexAttribArray(semantics.POSITION);
        gl.vertexAttribPointer(semantics.POSITION, 3, gl.FLOAT, false, stride = 24, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, vbos.wireframe);
        if (this.style === Style.WIREFRAME) {
          gl.lineWidth(1);
          gl.uniform1f(program.depthOffset, -0.01);
          this.setColor(program.color, COLORS.black, 0.75);
          gl.drawElements(gl.LINES, vbos.wireframe.count, gl.UNSIGNED_SHORT, 0);
        } else if (this.style === Style.RINGS) {
          gl.lineWidth(1);
          gl.uniform1f(program.depthOffset, -0.01);
          this.setColor(program.color, COLORS.black, 0.75);
          gl.drawElements(gl.LINES, vbos.wireframe.count / 2, gl.UNSIGNED_SHORT, vbos.wireframe.count);
        } else {
          gl.lineWidth(2);
          gl.uniform1f(program.depthOffset, 0.01);
          this.setColor(program.color, COLORS.black, 1);
          gl.drawElements(gl.LINES, vbos.wireframe.count, gl.UNSIGNED_SHORT, 0);
          if (this.sketchy) {
            gl.lineWidth(1);
            this.setColor(program.color, COLORS.darkgray, 1);
            gl.uniform1f(program.depthOffset, -0.01);
            gl.drawElements(gl.LINES, vbos.wireframe.count / 2, gl.UNSIGNED_SHORT, vbos.wireframe.count);
          }
        }
        return gl.disableVertexAttribArray(semantics.POSITION);
      }
    };

    Renderer.prototype.compileShaders = function() {
      var fs, metadata, name, vs, _ref, _ref1, _results;
      _ref = root.shaders;
      _results = [];
      for (name in _ref) {
        metadata = _ref[name];
        if (name === "source") {
          continue;
        }
        _ref1 = metadata.keys, vs = _ref1[0], fs = _ref1[1];
        _results.push(this.programs[name] = this.compileProgram(vs, fs, metadata.attribs, metadata.uniforms));
      }
      return _results;
    };

    Renderer.prototype.compileShader = function(name, type) {
      var handle, source, status;
      source = root.shaders.source[name];
      handle = gl.createShader(type);
      gl.shaderSource(handle, source);
      gl.compileShader(handle);
      status = gl.getShaderParameter(handle, gl.COMPILE_STATUS);
      if (!status) {
        $.gritter.add({
          title: "GLSL Error: " + name,
          text: gl.getShaderInfoLog(handle)
        });
      }
      return handle;
    };

    Renderer.prototype.compileProgram = function(vName, fName, attribs, uniforms) {
      var fShader, key, numUniforms, program, status, u, vShader, value, _i, _len;
      vShader = this.compileShader(vName, gl.VERTEX_SHADER);
      fShader = this.compileShader(fName, gl.FRAGMENT_SHADER);
      program = gl.createProgram();
      gl.attachShader(program, vShader);
      gl.attachShader(program, fShader);
      for (key in attribs) {
        value = attribs[key];
        gl.bindAttribLocation(program, value, key);
      }
      gl.linkProgram(program);
      status = gl.getProgramParameter(program, gl.LINK_STATUS);
      if (!status) {
        glerr("Could not link " + vName + " with " + fName);
      }
      numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);
      uniforms = (function() {
        var _i, _results;
        _results = [];
        for (u = _i = 0; 0 <= numUniforms ? _i < numUniforms : _i > numUniforms; u = 0 <= numUniforms ? ++_i : --_i) {
          _results.push(gl.getActiveUniform(program, u).name);
        }
        return _results;
      })();
      for (_i = 0, _len = uniforms.length; _i < _len; _i++) {
        u = uniforms[_i];
        program[u] = gl.getUniformLocation(program, u);
      }
      return program;
    };

    return Renderer;

  })();

  root.Renderer = Renderer;

  clone = utility.clone;

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = "sin cos pow abs".split(' ');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      _results.push(Math[f]);
    }
    return _results;
  })(), sin = _ref[0], cos = _ref[1], pow = _ref[2], abs = _ref[3];

  dot = vec3.dot;

  sgn = function(x) {
    if (x > 0) {
      return +1;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    }
  };

  TWOPI = 2 * Math.PI;

  aabb = utility.aabb;

  Style = {
    WIREFRAME: 0,
    SILHOUETTE: 1,
    RINGS: 2
  };

}).call(this);
