// Generated by CoffeeScript 1.3.1
(function() {
  var Renderer, TWOPI, abs, attrs, cos, dot, f, pow, root, sgn, sin, staticRender, _ref;

  root = typeof exports !== "undefined" && exports !== null ? exports : this;

  Renderer = (function() {

    Renderer.name = 'Renderer';

    function Renderer(gl, width, height) {
      this.gl = gl;
      this.width = width;
      this.height = height;
      this.theta = 0;
      this.vbos = {};
      this.programs = {};
      this.tubeGen = new root.TubeGenerator;
      this.genVertexBuffers();
      this.genMobius();
      this.compileShaders();
      this.genHugeTriangle();
      this.gl.disable(this.gl.CULL_FACE);
      if (this.gl.getError() !== this.gl.NO_ERROR) {
        glerr("OpenGL error during init");
      }
      this.render();
    }

    Renderer.prototype.compileShaders = function() {
      var fs, metadata, name, vs, _ref, _ref1, _results;
      _ref = root.shaders;
      _results = [];
      for (name in _ref) {
        metadata = _ref[name];
        _ref1 = metadata.keys, vs = _ref1[0], fs = _ref1[1];
        _results.push(this.programs[name] = this.compileProgram(vs, fs, metadata.attribs, metadata.uniforms));
      }
      return _results;
    };

    Renderer.prototype.render = function() {
      var aspect, eye, far, fov, model, modelview, near, normalMatrix, offset, program, projection, stride, target, up, view;
      window.requestAnimFrame(staticRender, $("canvas").get(0));
      projection = mat4.perspective(fov = 45, aspect = 1, near = 5, far = 90);
      view = mat4.lookAt(eye = [0, -5, 5], target = [0, 0, 0], up = [0, 1, 0]);
      model = mat4.create();
      modelview = mat4.create();
      mat4.identity(model);
      mat4.rotateY(model, this.theta);
      mat4.multiply(view, model, modelview);
      normalMatrix = mat4.toMat3(modelview);
      this.theta += 0.02;
      if (false) {
        program = this.programs.vignette;
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.useProgram(program);
        this.gl.uniform2f(program.viewport, this.width, this.height);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.bigtri);
        this.gl.enableVertexAttribArray(attrs.VERTEXID);
        this.gl.vertexAttribPointer(attrs.VERTEXID, 2, this.gl.FLOAT, false, stride = 8, 0);
        this.gl.drawArrays(this.gl.TRIANGLES, 0, 3);
        this.gl.disableVertexAttribArray(attrs.VERTEXID);
      }
      if (true) {
        this.gl.viewport(0, 0, this.width / 8, this.height / 8);
        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        program = this.programs.wireframe;
        this.gl.useProgram(program);
        this.gl.uniformMatrix4fv(program.projection, false, projection);
        this.gl.uniformMatrix4fv(program.modelview, false, modelview);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.centerline);
        this.gl.enableVertexAttribArray(attrs.POSITION);
        this.gl.vertexAttribPointer(attrs.POSITION, 3, this.gl.FLOAT, false, stride = 12, 0);
        this.gl.uniform1f(program.scale, 1);
        this.gl.lineWidth(5);
        this.gl.uniform4f(program.color, 0, 0, 0, 0.75);
        this.gl.uniform1f(program.depthOffset, 0);
        this.gl.drawArrays(this.gl.LINE_STRIP, 0, this.vbos.centerline.count);
        this.gl.lineWidth(2);
        this.gl.uniform4f(program.color, 1, 1, 1, 0.75);
        this.gl.uniform1f(program.depthOffset, -0.01);
        this.gl.drawArrays(this.gl.LINE_STRIP, 0, this.vbos.centerline.count);
        this.gl.disableVertexAttribArray(attrs.POSITION);
        this.gl.viewport(0, 0, this.width, this.height);
      }
      if (true) {
        this.gl.disable(this.gl.DEPTH_TEST);
        this.gl.enable(this.gl.BLEND);
        this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
        this.gl.lineWidth(1);
        program = this.programs.wireframe;
        this.gl.useProgram(program);
        this.gl.uniformMatrix4fv(program.projection, false, projection);
        this.gl.uniformMatrix4fv(program.modelview, false, modelview);
        this.gl.uniform4f(program.color, 0.5, 0.9, 1, 0.5);
        this.gl.uniform1f(program.depthOffset, 0);
        this.gl.uniform1f(program.scale, 1);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.tube);
        this.gl.enableVertexAttribArray(attrs.POSITION);
        this.gl.vertexAttribPointer(attrs.POSITION, 3, this.gl.FLOAT, false, stride = 12, 0);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.vbos.wireframe);
        this.gl.drawElements(this.gl.LINES, this.vbos.wireframe.count, this.gl.UNSIGNED_SHORT, 0);
        this.gl.disableVertexAttribArray(attrs.POSITION);
      }
      if (false) {
        program = this.programs.mesh;
        this.gl.clear(this.gl.DEPTH_BUFFER_BIT);
        this.gl.enable(this.gl.DEPTH_TEST);
        this.gl.useProgram(program);
        this.gl.uniformMatrix4fv(program.projection, false, projection);
        this.gl.uniformMatrix4fv(program.modelview, false, modelview);
        this.gl.uniformMatrix3fv(program.normalmatrix, false, normalMatrix);
        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.vbos.mesh);
        this.gl.enableVertexAttribArray(attrs.POSITION);
        this.gl.enableVertexAttribArray(attrs.NORMAL);
        this.gl.vertexAttribPointer(attrs.POSITION, 3, this.gl.FLOAT, false, stride = 32, 0);
        this.gl.vertexAttribPointer(attrs.NORMAL, 3, this.gl.FLOAT, false, stride = 32, offset = 12);
        this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.vbos.faces);
        this.gl.drawElements(this.gl.TRIANGLES, this.vbos.faces.count, this.gl.UNSIGNED_SHORT, 0);
        this.gl.disableVertexAttribArray(attrs.POSITION);
        this.gl.disableVertexAttribArray(attrs.NORMAL);
      }
      if (this.gl.getError() !== this.gl.NO_ERROR) {
        return glerr("Render");
      }
    };

    Renderer.prototype.genVertexBuffers = function() {
      var i, j, lineCount, polygonCount, polygonEdge, ptr, rawBuffer, sides, sweepEdge, vbo, _ref, _ref1;
      rawBuffer = this.tubeGen.getLinkPaths(window.knot_data)[0];
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      this.vbos.centerline = vbo;
      this.vbos.centerline.count = rawBuffer.length / 3;
      rawBuffer = this.tubeGen.generateTube(rawBuffer);
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      console.log("Tube positions has " + (rawBuffer.length / 3) + " verts.");
      this.vbos.tube = vbo;
      polygonCount = this.vbos.centerline.count - 1;
      sides = this.tubeGen.polygonSides;
      lineCount = polygonCount * sides * 2;
      rawBuffer = new Uint16Array(lineCount * 2);
      _ref = [0, 0], i = _ref[0], ptr = _ref[1];
      while (i < polygonCount * (sides + 1)) {
        j = 0;
        while (j < sides) {
          polygonEdge = rawBuffer.subarray(ptr + 0, ptr + 2);
          polygonEdge[0] = i + j;
          polygonEdge[1] = i + j + 1;
          sweepEdge = rawBuffer.subarray(ptr + 2, ptr + 4);
          sweepEdge[0] = i + j;
          sweepEdge[1] = i + j + sides + 1;
          _ref1 = [ptr + 4, j + 1], ptr = _ref1[0], j = _ref1[1];
        }
        i += sides + 1;
      }
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      this.vbos.wireframe = vbo;
      this.vbos.wireframe.count = rawBuffer.length;
      return console.log("Tube wireframe has " + rawBuffer.length + " indices for " + sides + " sides and " + (this.vbos.centerline.count - 1) + " polygons.");
    };

    Renderer.prototype.genHugeTriangle = function() {
      var corners, rawBuffer, vbo;
      corners = [-1, 3, -1, -1, 3, -1];
      rawBuffer = new Float32Array(corners);
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      return this.vbos.bigtri = vbo;
    };

    Renderer.prototype.genMobius = function() {
      var A, B, BmA, C, CmA, EPSILON, N, Slices, Stacks, faceCount, i, j, msg, n, next, p, ptr, rawBuffer, slice, stack, tri, u, v, vbo, _ref, _ref1, _ref2, _ref3;
      _ref = [128, 64], Slices = _ref[0], Stacks = _ref[1];
      rawBuffer = new Float32Array(Slices * Stacks * 8);
      _ref1 = [-1, 0], slice = _ref1[0], i = _ref1[1];
      BmA = CmA = n = N = vec3.create();
      EPSILON = 0.00001;
      while (++slice < Slices) {
        _ref2 = [slice * TWOPI / (Slices - 1), -1], v = _ref2[0], stack = _ref2[1];
        while (++stack < Stacks) {
          u = stack * TWOPI / (Stacks - 1);
          A = p = this.evalMobius(u, v);
          B = this.evalMobius(u + EPSILON, v);
          C = this.evalMobius(u, v + EPSILON);
          BmA = vec3.subtract(B, A);
          CmA = vec3.subtract(C, A);
          n = vec3.cross(BmA, CmA);
          n = vec3.normalize(n);
          rawBuffer.set(p, i);
          rawBuffer.set(n, i + 3);
          rawBuffer.set([u, v], i + 6);
          i += 8;
        }
      }
      msg = "" + i + " floats generated from " + Slices + " slices and " + Stacks + " stacks.";
      console.log(msg);
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      this.vbos.mesh = vbo;
      faceCount = (Slices - 1) * Stacks * 2;
      rawBuffer = new Uint16Array(faceCount * 3);
      _ref3 = [0, 0, 0], i = _ref3[0], ptr = _ref3[1], v = _ref3[2];
      while (++i < Slices) {
        j = -1;
        while (++j < Stacks) {
          next = (j + 1) % Stacks;
          tri = rawBuffer.subarray(ptr + 0, ptr + 3);
          tri[2] = v + next + Stacks;
          tri[1] = v + next;
          tri[0] = v + j;
          tri = rawBuffer.subarray(ptr + 3, ptr + 6);
          tri[2] = v + j;
          tri[1] = v + j + Stacks;
          tri[0] = v + next + Stacks;
          ptr += 6;
        }
        v += Stacks;
      }
      vbo = this.gl.createBuffer();
      this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, vbo);
      this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, rawBuffer, this.gl.STATIC_DRAW);
      this.vbos.faces = vbo;
      return this.vbos.faces.count = rawBuffer.length;
    };

    Renderer.prototype.evalMobius = function(u, v) {
      var R, n, x, y, z, _ref;
      _ref = [1.5, 3], R = _ref[0], n = _ref[1];
      x = (1.0 * R + 0.125 * sin(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v)) + 0.5 * cos(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v))) * cos(u);
      y = (1.0 * R + 0.125 * sin(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v)) + 0.5 * cos(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v))) * sin(u);
      z = -0.5 * sin(u / 2) * pow(abs(cos(v)), 2 / n) * sgn(cos(v)) + 0.125 * cos(u / 2) * pow(abs(sin(v)), 2 / n) * sgn(sin(v));
      return [x, y, z];
    };

    Renderer.prototype.compileProgram = function(vName, fName, attribs, uniforms) {
      var fs, key, program, value, vs;
      vs = getShader(this.gl, vName);
      fs = getShader(this.gl, fName);
      program = this.gl.createProgram();
      this.gl.attachShader(program, vs);
      this.gl.attachShader(program, fs);
      for (key in attribs) {
        value = attribs[key];
        this.gl.bindAttribLocation(program, value, key);
      }
      this.gl.linkProgram(program);
      if (!this.gl.getProgramParameter(program, this.gl.LINK_STATUS)) {
        glerr('Could not link #{vName} with #{fName}');
      }
      for (key in uniforms) {
        value = uniforms[key];
        program[value] = this.gl.getUniformLocation(program, key);
      }
      return program;
    };

    return Renderer;

  })();

  root.Renderer = Renderer;

  _ref = (function() {
    var _i, _len, _ref, _results;
    _ref = "sin cos pow abs".split(' ');
    _results = [];
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      f = _ref[_i];
      _results.push(Math[f]);
    }
    return _results;
  })(), sin = _ref[0], cos = _ref[1], pow = _ref[2], abs = _ref[3];

  dot = vec3.dot;

  sgn = function(x) {
    if (x > 0) {
      return +1;
    } else {
      if (x < 0) {
        return -1;
      } else {
        return 0;
      }
    }
  };

  TWOPI = 2 * Math.PI;

  attrs = root.semantics;

  staticRender = function() {
    return root.renderer.render();
  };

}).call(this);
